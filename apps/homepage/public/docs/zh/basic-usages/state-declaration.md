# 对状态变量的重新思考

想象一下，在你的应用程序中管理状态就像声明一个变量一样简单 —— 不喧闹，也不需要特殊处理。你只需声明它，在视图中使用它，然后，嘿！对变量的任何更改都会自动更新视图。听起来很梦幻，不是吗？

因为在核心，什么是状态？它是一个在改变时，会自然地导致视图更新的变量。它是独特的，但却又并不是那么独特，对吧？它应该和代码中的任何其他变量一样易于使用。

现在我们已经看到，这个故事在前端框架的领域中以不同的方式展开。大多数框架需要一些仪式感，比如使用 `useState()` 或 `ref()`，或者其他形式的声明，然而像 Svelte 这样的框架则朝着简单性迈出了大胆的一步。

但即使使用 Svelte 时，在处理计算状态时也会出现一些小问题，它们需要额外的特殊关注，就像这样：

```js
let count = 0;
$: doubled = count * 2;
```

这部分也正是 DLight 的闪光点，它毫不费力地将简单性和功能性融合在状态管理中。

但它是如何实现的，以及你能够怎样充分利用它呢？让我们深入了解细节，并让您了解如何充分利用 DLight 中的状态！

# 声明一个状态

在一个 DLight 类组件中声明状态很简单直接: <!--（🤔疑惑）-->

```js
@View
class Counter {
  count = 0

  Body() {
    div(this.count)
    button("+")
      .onclick(() => {
        this.count ++
      })
  }
}
```

你只需声明一个普通的类属性，就完成了！你不需要将其与其他非 UI 渲染的变量区分开来。

因为 DLight 状态管理的核心思想便是每个属性既是状态，又不是状态：你在视图中使用它吗？那它就是状态。你没有在视图中使用它吗？好，那它就不是状态。

# 计算状态

在一个 DLight 类组件中声明一个计算状态也同样很简单：

```js
@View
class Counter {
  count = 0
  doubleCount = this.count * 2

  Body() {
    div(this.doubleCount)
      .onclick(() => {
        this.count ++
      })
  }
}
```

DLight 作为一个以开发体验为主的库的整体理念是，你不会感到挣扎。你不需要额外的步骤来完成本应从一开始就已经完成的任务。因此，你也不需要使用 `useMemo()` 或 `createMemo()` 来减少重新渲染或减少重新计算。凭着你的直觉是一切的关键。

不需要使用 `useMemo()` 或 `createMemo()` 来减少重新渲染或减少重新计算。 <!--（🤔疑惑）-->
