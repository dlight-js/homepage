const N = {}; "global" in N || (typeof window < "u" ? N.global = window : typeof global < "u" ? N.global = global : N.global = {}); "document" in N || typeof document < "u" && (N.document = document); const r = N; function O(i) { r.global = i } function H(i) { r.document = i } const c = { Comp: 0, For: 1, Cond: 2, Env: 3, Exp: 4, Subview: 5 }; var u = class {_$dlNodeType; constructor(t) { this._$dlNodeType = t } get _$el() { return u.toEls(this._$nodes) } static toEls(t) { const e = []; return this.loopShallowEls(t, n => { e.push(n) }), e } static loopShallowEls(t, e) { t.forEach(n => { if (!("_$dlNodeType" in n)) return e(n); n._$nodes && u.loopShallowEls(n._$nodes, e) }) } static addParentEl(t, e) { t.forEach(n => { "_$dlNodeType" in n && (n._$parentEl = e, n._$nodes && u.addParentEl(n._$nodes, e)) }) } static getFlowIndexFromNodes(t, e) { let n = 0; const s = [...t]; for (;s.length > 0;) { const o = s.shift(); if (o === e) break; "_$dlNodeType" in o ? o._$nodes && s.unshift(...o._$nodes) : n++ } return n } static appendNodesWithSibling(t, e, n) { return n ? this.insertNodesBefore(t, e, n) : this.appendNodes(t, e) } static appendNodesWithIndex(t, e, n, s) { return s = s ?? e.childNodes.length, s !== n ? this.insertNodesBefore(t, e, e.childNodes[n]) : this.appendNodes(t, e) } static insertNodesBefore(t, e, n) { let s = 0; return this.loopShallowEls(t, o => { e.insertBefore(o, n), s++ }), s } static appendNodes(t, e) { let n = 0; return this.loopShallowEls(t, s => { e.appendChild(s), n++ }), n } static addWillUnmount(t, e) { const n = r.global.WillUnmountStore; const s = n[n.length - 1]; s && s.push(e.bind(null, t)) } static addDidUnmount(t, e) { const n = r.global.DidUnmountStore; const s = n[n.length - 1]; s && s.push(e.bind(null, t)) } static addDidMount(t, e) { r.global.DidMountStore || (r.global.DidMountStore = []), r.global.DidMountStore.push(e.bind(null, t)) } static runDidMount() { const t = r.global.DidMountStore; if (!(!t || t.length === 0)) { for (let e = t.length - 1; e >= 0; e--)t[e](); r.global.DidMountStore = [] } }}; function K(i, t) { Object.assign(i.style, t) } function j(i, t) { Object.assign(i.dataset, t) } function _(i, t, e) { const n = `$${t}`; n in i && i[n] === e || (i[t] = e, i[n] = e) } function A(i, t) { Object.entries(t).forEach(([e, n]) => { _(i, e, n) }) } function L(i, t, e) { const n = `$${t}`; n in i && i[n] === e || (i.setAttribute(t, e), i[n] = e) } function C(i, t) { Object.entries(t).forEach(([e, n]) => { L(i, e, n) }) } function V(i, t, e) { const n = i[`$on${t}`]; n && i.removeEventListener(t, n), i.addEventListener(t, e), i[`$on${t}`] = e } function Y(i) { return r.document.createElement(i) } function F(i, t, e) { i._$nodes || (i._$nodes = Array.from(i.childNodes)), i._$nodes.splice(e, 0, t); const n = u.getFlowIndexFromNodes(i._$nodes, t); u.appendNodesWithIndex([t], i, n), u.addParentEl([t], i) } function M(i, t, e) { if (t === "style") { K(i, e); return } if (t === "dataset") { j(i, e); return } if (t !== "element") { if (t === "prop") { A(i, e); return } if (t === "attr") { C(i, e); return } if (t === "innerHTML") { _(i, "innerHTML", e); return } if (t !== "forwardProp") { if (t.startsWith("on")) { V(i, t.slice(2).toLowerCase(), e); return }L(i, t, e) } } } const v = class extends u {constructor() { super(c.Comp) }_$init(t, e, n, s) { this._$notInitd = !0, s && s._$addForwardProps(this), e !== null && this._$setContent(e), t && Object.entries(t).forEach(([o, a]) => { this._$setProp(o, a) }), n && (this._$children = n), r.global.DLEnvStore && Object.entries(r.global.DLEnvStore.envs).forEach(([o, [a, h]]) => { h.addNode(this), this._$initEnv(o, a, h) }), this._$callUpdatesBeforeInit(), this.didMount && u.addDidMount(this, this.didMount.bind(this)), this.willUnmount && u.addWillUnmount(this, this.willUnmount.bind(this)), this.didUnmount && u.addDidUnmount(this, this.didUnmount.bind(this)), this.willMount?.(), this._$nodes = this.View?.() ?? [] }_$callUpdatesBeforeInit() { const t = Object.getOwnPropertyNames(Object.getPrototypeOf(this)); const e = Object.getOwnPropertyNames(this); [...t, ...e].forEach(s => { if (s.startsWith("$w$")) return this[s.slice(3)](); s.startsWith("$f$") && (this[`$${s.slice(3)}`] = this[s]) }), delete this._$notInitd }_$setForwardProp(t, e) { if (t in this) { this[t] = e; return } this._$forwardPropsId.push(t); const n = `$${t}`; this[n] = e, Object.defineProperty(this, t, { get() { return this[n] }, set(s) { this[n] !== s && (this[n] = s, this._$forwardPropsSet?.forEach(o => { o._$dlNodeType === c.Comp && o._$setProp(t, s), o instanceof HTMLElement && M(o, t, s) })) } }) }_$addForwardProps(t) { this._$forwardPropsSet.add(t), this._$forwardPropsId.forEach(e => { const n = this[e]; this._$forwardPropsSet?.forEach(s => { s._$dlNodeType === c.Comp && ("_$forwardProps" in s && s._$forwardPropsId.push(e), s._$setProp(e, n)), s instanceof HTMLElement && M(s, e, n) }) }), u.addWillUnmount(t, this._$forwardPropsSet.delete.bind(this._$forwardPropsSet, t)) }_$setProp(t, e) { "_$forwardProps" in this && this._$setForwardProp(t, e), `$p$${t}` in this && (this[t] = e) }_$initEnv(t, e, n) { `$e$${t}` in this && (this[t] = e, this[`$en$${t}`] = n) }_$updateEnv(t, e, n) { `$e$${t}` in this && n === this[`$en$${t}`] && this[t] !== e && (this[t] = e) }_$setContent(t) { const e = this._$contentKey; e && this[e] !== t && (this[e] = t) }_$updateProp(t, e) { const n = `$${t}`; if (this[n] === e) return; const s = this[n]; this[n] = e, this._$updateDerived(t, s, e), this._$updateView(t, s, e) }_$updateDerived(t, e, n) { "_$notInitd" in this || this[`$s$${t}`]?.forEach(s => { `$w$${s}` in this ? this[s](t, e, n) : this[`$${s}`] = this[`$f$${s}`] }) }_$updateView(t, e, n) { const s = this[`$$${t}`]; s && this._$update?.(s, t, e, n) }}; const nt = v; function st(i, t) { i._$updateDerived(t), i._$updateView(t) } const S = class {constructor() { this.envs = {}, this.currentEnvNodes = [] }addEnvNode(t) { this.currentEnvNodes.push(t), this.mergeEnvs() }replaceEnvNodes(t) { this.currentEnvNodes = t, this.mergeEnvs() }removeEnvNode() { this.currentEnvNodes.pop(), this.mergeEnvs() }mergeEnvs() { this.envs = {}, this.currentEnvNodes.forEach(t => { Object.entries(t.envs).forEach(([e, n]) => { this.envs[e] = [n, t] }) }) }}; const I = class extends u {constructor(t) { super(c.Env), "DLEnvStore" in r.global || (r.global.DLEnvStore = new S()), this.envs = t, this.updateNodes = new Set(), r.global.DLEnvStore.addEnvNode(this) }updateEnv(t, e) { this.envs[t] = e, r.global.DLEnvStore.currentEnvNodes.includes(this) && r.global.DLEnvStore.mergeEnvs(), this.updateNodes.forEach(n => { n._$updateEnv(t, e, this) }) }addNode(t) { this.updateNodes.add(t), u.addWillUnmount(t, this.updateNodes.delete.bind(this.updateNodes, t)) }initNodes(t) { this._$nodes = t, r.global.DLEnvStore.removeEnvNode() }}; function ht(i) { return r.document.createTextNode(i) } function lt(i, t) { i.textContent !== t && (i.textContent = t) } const W = class {propViewFunc; dlUpdateFunc = new Set(); constructor(t) { this.propViewFunc = t }build() { let t; const e = s => { t = s, this.dlUpdateFunc.add(s) }; const n = this.propViewFunc(e); return n.length === 0 ? [] : (t && u.addWillUnmount(n[0], this.dlUpdateFunc.delete.bind(this.dlUpdateFunc, t)), n) }update(...t) { this.dlUpdateFunc.forEach(e => { e(...t) }) }}; const P = class extends u {constructor() { super(c.Subview) }}; const E = class extends u {constructor(t) { super(t), r.global.DLEnvStore && r.global.DLEnvStore.currentEnvNodes.length > 0 && (this.savedEnvNodes = [...r.global.DLEnvStore.currentEnvNodes]) }initNewNodes(t) { u.addParentEl(t, this._$parentEl) }geneNewNodesInEnv(t) { if (!this.savedEnvNodes) { const s = t(); return this.initNewNodes(s), s } const e = r.global.DLEnvStore.currentEnvNodes; r.global.DLEnvStore.replaceEnvNodes(this.savedEnvNodes); const n = t(); return r.global.DLEnvStore.replaceEnvNodes(e), this.initNewNodes(n), n }initUnmountStore() { r.global.WillUnmountStore.push([]), r.global.DidUnmountStore.push([]) }removeNodes(t) { u.loopShallowEls(t, e => { this._$parentEl.removeChild(e) }) }}; var p = class extends E {array; nodeFunc; depNum; nodesMap = new Map(); updateArr = []; get _$nodes() { const t = []; for (let e = 0; e < this.array.length; e++)t.push(...this.nodesMap.get(this.keys?.[e] ?? e)); return t }constructor(t, e, n) { super(c.For), this.array = [...t], this.keys = n, this.depNum = e }addNodeFunc(t) { this.nodeFunc = t, this.array.forEach((e, n) => { this.initUnmountStore(); const s = this.keys?.[n] ?? n; const o = t(e, this.updateArr, n); this.nodesMap.set(s, o), this.setUnmountMap(s) }), p.addWillUnmount(this, this.runAllWillUnmount.bind(this)), p.addDidUnmount(this, this.runAllDidUnmount.bind(this)) }update(t, ...e) { if (!(t & this.depNum)) { this.updateArgs = e; for (let n = 0; n < this.array.length; n++) this.updateItem(n, this.array, t) } }updateItem(t, e, n) { this.updateArr[t]?.(n ?? this.depNum, ...this.updateArgs, e[t]) }updateArray(t, e, n, s, o) { if (this.updateArgs = [e, n, s], o) { this.updateWithKey(t, o); return } this.updateWithOutKey(t) }getNewNodes(t, e, n, s) { this.initUnmountStore(); const o = this.geneNewNodesInEnv(() => this.nodeFunc(n[t], s ?? this.updateArr, t)); return this.setUnmountMap(e), this.nodesMap.set(e, o), o }setUnmountMap(t) { const e = r.global.WillUnmountStore.pop(); e && e.length > 0 && (this.willUnmountMap || (this.willUnmountMap = new Map()), this.willUnmountMap.set(t, e)); const n = r.global.DidUnmountStore.pop(); n && n.length > 0 && (this.didUnmountMap || (this.didUnmountMap = new Map()), this.didUnmountMap.set(t, n)) }runAllWillUnmount() { !this.willUnmountMap || this.willUnmountMap.size === 0 || (this.willUnmountMap.forEach(t => { for (let e = 0; e < t.length; e++)t[e]?.() }), this.willUnmountMap.clear()) }runAllDidUnmount() { !this.didUnmountMap || this.didUnmountMap.size === 0 || (this.didUnmountMap.forEach(t => { for (let e = t.length - 1; e >= 0; e--)t[e]?.() }), this.didUnmountMap.clear()) }runWillUnmount(t) { if (!this.willUnmountMap || this.willUnmountMap.size === 0) return; const e = this.willUnmountMap.get(t); if (e) { for (let n = 0; n < e.length; n++)e[n]?.(); this.willUnmountMap.delete(t) } }runDidUnmount(t) { if (!this.didUnmountMap || this.didUnmountMap.size === 0) return; const e = this.didUnmountMap.get(t); if (e) { for (let n = e.length - 1; n >= 0; n--)e[n]?.(); this.didUnmountMap.delete(t) } }removeNodes(t, e) { this.runWillUnmount(e), super.removeNodes(t), this.runDidUnmount(e), this.nodesMap.delete(e) }updateWithOutKey(t) { const e = this.array.length; const n = t.length; if (e === n) { for (let o = 0; o < this.array.length; o++) this.updateItem(o, t); this.array = [...t]; return } const s = this._$parentEl; if (e < n) { let o = p.getFlowIndexFromNodes(s._$nodes, this); const a = s.childNodes.length; for (let h = 0; h < n; h++) { if (h < e) { o += p.getFlowIndexFromNodes(this.nodesMap.get(h)), this.updateItem(h, t); continue } const g = this.getNewNodes(h, h, t); p.appendNodesWithIndex(g, s, o, a) }p.runDidMount(), this.array = [...t]; return } for (let o = 0; o < n; o++) this.updateItem(o, t); for (let o = n; o < e; o++) { const a = this.nodesMap.get(o); this.removeNodes(a, o) } this.updateArr.splice(n, e - n), this.array = [...t] }updateWithKey(t, e) { if (e.length !== new Set(e).size) throw new Error("DLight: Duplicate keys in for loop are not allowed"); const n = this.keys; if (this.keys = e, p.arrayEqual(n, this.keys)) { for (let d = 0; d < t.length; d++) this.updateItem(d, t); this.array = [...t]; return } const s = this._$parentEl; if (this.keys.length === 0) { const d = s._$nodes ?? []; if (d.length === 1 && d[0] === this) this.runAllWillUnmount(), s.innerHTML = "", this.runAllDidUnmount(); else for (let l = 0; l < n.length; l++) { const f = n[l]; this.removeNodes(this.nodesMap.get(f), f) } this.nodesMap.clear(), this.updateArr = [], this.array = []; return } const o = p.getFlowIndexFromNodes(s._$nodes, this); if (n.length === 0) { const d = s.childNodes[o]; for (let l = 0; l < this.keys.length; l++) { const f = this.getNewNodes(l, this.keys[l], t); p.appendNodesWithSibling(f, s, d) }p.runDidMount(), this.array = [...t]; return } const a = []; const h = []; for (let d = 0; d < n.length; d++) { const l = n[d]; if (this.keys.includes(l)) { a.push(l), h.push(this.updateArr[d]); continue } this.removeNodes(this.nodesMap.get(l), l) } let g = s.childNodes.length; let $ = o; for (let d = 0; d < this.keys.length; d++) { const l = this.keys[d]; if (a.includes(l)) { $ += p.getFlowIndexFromNodes(this.nodesMap.get(l)), this.updateItem(d, t); continue }h.splice(d, 0, null); const f = this.getNewNodes(d, l, t, h); a.splice(d, 0, l); const w = p.appendNodesWithIndex(f, s, $, g); $ += w, g += w } if (p.runDidMount(), p.arrayEqual(this.keys, a)) { this.array = [...t], this.updateArr = h; return }$ = o; const D = []; for (let d = 0; d < this.keys.length; d++) { const l = this.keys[d]; const f = a.indexOf(l); const w = D[d]; if (w) { const b = p.appendNodesWithIndex(w, s, $ + p.getFlowIndexFromNodes(w), g); $ += b, g += b, D[d] = void 0 } else if (f === d) { $ += p.getFlowIndexFromNodes(this.nodesMap.get(l)); continue } else { D[this.keys.indexOf(a[d])] = this.nodesMap.get(this.keys[f]); const b = p.appendNodesWithIndex(this.nodesMap.get(l), s, $, g); $ += b, g += b } const T = a[d]; a[d] = a[f], a[f] = T; const y = h[d]; h[d] = h[f], h[f] = y } this.array = [...t], this.updateArr = h } static arrayEqual(t, e) { return t.length !== e.length ? !1 : t.every((n, s) => n === e[s]) }}; const x = class extends E {willUnmountFuncs = []; didUnmountFuncs = []; setUnmountFuncs() { this.willUnmountFuncs = r.global.WillUnmountStore.pop(), this.didUnmountFuncs = r.global.DidUnmountStore.pop() }runWillUnmount() { for (let t = 0; t < this.willUnmountFuncs.length; t++) this.willUnmountFuncs[t]() }runDidUnmount() { for (let t = this.didUnmountFuncs.length - 1; t >= 0; t--) this.didUnmountFuncs[t]() }removeNodes(t) { this.runWillUnmount(), super.removeNodes(t), this.runDidUnmount() }geneNewNodesInEnv(t) { this.initUnmountStore(); const e = super.geneNewNodesInEnv(t); return this.setUnmountFuncs(), e }}; var m = class extends x {nodesFunc; constructor(t) { super(c.Exp), this.nodesFunc = t, this.initUnmountStore(), this._$nodes = m.formatNodes(t()), this.setUnmountFuncs(), m.addWillUnmount(this, this.runWillUnmount.bind(this)), m.addDidUnmount(this, this.runDidUnmount.bind(this)) }update() { this.removeNodes(this._$nodes); const t = this.geneNewNodesInEnv(() => m.formatNodes(this.nodesFunc())); if (t.length === 0) { this._$nodes = []; return } const e = this._$parentEl; const n = m.getFlowIndexFromNodes(e._$nodes, this); const s = e.childNodes[n]; m.appendNodesWithSibling(t, e, s), m.runDidMount(), this._$nodes = t } static formatNodes(t) { return Array.isArray(t) || (t = [t]), t.flat(1).filter(e => e != null && typeof e !== "boolean").map(e => typeof e === "string" || typeof e === "number" || typeof e === "bigint" ? r.document.createTextNode(`${e}`) : "propViewFunc" in e ? e.build() : e).flat(1) }}; var U = class extends x {condFunc; cond; depNum; constructor(t) { super(c.Cond), this.depNum = t }addCondFunc(t) { this.cond = -1, this.condFunc = t, this.initUnmountStore(), this._$nodes = this.condFunc(this), this.setUnmountFuncs(), U.addWillUnmount(this, this.runWillUnmount.bind(this)), U.addDidUnmount(this, this.runDidUnmount.bind(this)) }updateCond(...t) { const e = [this.willUnmountFuncs, this.didUnmountFuncs]; const n = this.geneNewNodesInEnv(() => this.condFunc(this)); if (this.didntChange) return [this.willUnmountFuncs, this.didUnmountFuncs] = e, this.didntChange = !1, this.updateFunc?.(this.depNum, ...t), this._$nodes; const s = [this.willUnmountFuncs, this.didUnmountFuncs]; if ([this.willUnmountFuncs, this.didUnmountFuncs] = e, this._$nodes && this._$nodes.length > 0 && this.removeNodes(this._$nodes), [this.willUnmountFuncs, this.didUnmountFuncs] = s, n.length === 0) return this._$nodes = [], this._$nodes; const o = this._$parentEl; const a = U.getFlowIndexFromNodes(o._$nodes, this); const h = o.childNodes[a]; return U.appendNodesWithSibling(n, o, h), U.runDidMount(), this._$nodes = n, this._$nodes }update(t, ...e) { t & this.depNum || this.updateFunc?.(t, ...e) }}; function B() { r.global.WillUnmountStore = [], r.global.DidUnmountStore = [] } function Ot(i, t) { let e = i; if (typeof i === "string") { const s = r.document.getElementById(i); if (s)e = s; else throw new Error(`DLight: Element with id ${i} not found`) }B(), e.innerHTML = ""; const n = new t(); n._$init(), F(e, n, 0), u.runDidMount() } function Ht(i, t) { return i() } function z(i) { return i } const Kt = z; export { Kt as $, v as CompNode, U as CondNode, I as EnvNode, S as EnvStoreClass, m as ExpNode, p as ForNode, W as PropView, P as SubViewNode, nt as View, Y as createElement, ht as createTextNode, z as escape, M as forwardHTMLProp, F as insertNode, Ht as manual, Ot as render, j as setDataset, H as setDocument, V as setEvent, O as setGlobal, L as setHTMLAttr, C as setHTMLAttrs, _ as setHTMLProp, A as setHTMLProps, K as setStyle, st as update, lt as updateText }
// # sourceMappingURL=index.js.map
